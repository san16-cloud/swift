name: "Deploy via SSM"
description: "Deploys application to EC2 instance using SSM"

inputs:
  instance_id:
    description: "EC2 instance ID"
    required: false
  instance_ip:
    description: "EC2 instance IP"
    required: true
  docker_compose_base64:
    description: "Base64 encoded docker-compose.yml"
    required: true
  deployment_script_base64:
    description: "Base64 encoded deployment script"
    required: true
  registry:
    description: "ECR registry URL"
    required: true
  aws_region:
    description: "AWS region"
    required: true
  container_image_api:
    description: "Full image URI for API container"
    required: false
  container_image_web:
    description: "Full image URI for web container"
    required: false

runs:
  using: "composite"
  steps:
    - name: Deploy using direct SSM command
      shell: bash
      run: |
        INSTANCE_ID="${{ inputs.instance_id }}"
        INSTANCE_IP="${{ inputs.instance_ip }}"
        REGISTRY="${{ inputs.registry }}"
        CONTAINER_IMAGE_API="${{ inputs.container_image_api }}"
        CONTAINER_IMAGE_WEB="${{ inputs.container_image_web }}"
        AWS_REGION="${{ inputs.aws_region }}"

        echo "Using instance IP: $INSTANCE_IP"
        echo "Using instance ID: $INSTANCE_ID"
        echo "Using container images:"
        echo "  API: $CONTAINER_IMAGE_API"
        echo "  Web: $CONTAINER_IMAGE_WEB"

        # Check if we're using fallback values for instance ID only (instance IP can be derived)
        if [[ "$INSTANCE_ID" == "fallback_id_for_pipeline_continuity" ]]; then
          echo "Instance ID is a fallback value."
          # Try to get the real instance ID from the IP if the IP is valid
          if [[ "$INSTANCE_IP" != "fallback_ip_for_pipeline_continuity" && "$INSTANCE_IP" != "plan_only_mode" ]]; then
            echo "Attempting to find instance ID using IP address $INSTANCE_IP..."
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=public-ip-address,Values=$INSTANCE_IP" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)
              
            if [ "$INSTANCE_ID" == "None" ] || [ -z "$INSTANCE_ID" ]; then
              echo "Error: Could not find instance with IP $INSTANCE_IP"
              exit 1
            else
              echo "Found instance ID: $INSTANCE_ID"
            fi
          else
            echo "ERROR: Received fallback values for infrastructure parameters."
            echo "This indicates that Terraform did not properly output instance information."
            echo "Deployment cannot proceed."
            exit 1
          fi
        fi

        echo "Deploying to instance: $INSTANCE_ID"
        echo "Using AWS region: $AWS_REGION"

        # Check if we can connect to the instance via SSM
        CONNECTION_STATUS=$(aws ssm describe-instance-information \
          --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
          --query "InstanceInformationList[0].PingStatus" \
          --output text)
          
        if [ "$CONNECTION_STATUS" != "Online" ]; then
          echo "Warning: Instance $INSTANCE_ID is not currently connected to SSM (status: $CONNECTION_STATUS)"
          echo "Waiting for SSM connection to become available..."
          
          # Wait for up to 2 minutes
          for i in {1..12}; do
            sleep 10
            CONNECTION_STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text)
              
            if [ "$CONNECTION_STATUS" == "Online" ]; then
              echo "Instance is now connected to SSM!"
              break
            fi
            
            if [ $i -eq 12 ]; then
              echo "Error: Instance failed to connect to SSM after 2 minutes"
              echo "Please ensure the instance has an IAM role with SSM permissions and the SSM agent is running"
              exit 1
            fi
          done
        fi

        # Create config file from template
        CONFIG_TEMPLATE="$GITHUB_WORKSPACE/.github/workflows/deploy/templates/config.json.template"
        CONFIG_FILE="$(mktemp)"
        
        # Replace variables in the template using sed (more portable than envsubst)
        sed -e "s|\${REGISTRY}|$REGISTRY|g" \
            -e "s|\${AWS_REGION}|$AWS_REGION|g" \
            -e "s|\${CONTAINER_IMAGE_API}|$CONTAINER_IMAGE_API|g" \
            -e "s|\${CONTAINER_IMAGE_WEB}|$CONTAINER_IMAGE_WEB|g" \
            "$CONFIG_TEMPLATE" > "$CONFIG_FILE"
            
        CONFIG_BASE64=$(base64 -w 0 "$CONFIG_FILE")
        
        # Send command to instance using SSM document with explicit environment variable setting
        CMD_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"echo 'Starting Swift deployment...'\",
            \"mkdir -p /tmp/swift-deploy\",
            \"cd /tmp/swift-deploy\",
            \"echo ${{ inputs.docker_compose_base64 }} | base64 --decode > docker-compose.yml\",
            \"echo ${{ inputs.deployment_script_base64 }} | base64 --decode > run-deployment.sh\", 
            \"echo $CONFIG_BASE64 | base64 --decode > config.json\",
            \"chmod +x run-deployment.sh\",
            \"export AWS_ECR_REGISTRY='$REGISTRY'\", 
            \"export AWS_REGION='$AWS_REGION'\",
            \"export CONTAINER_IMAGE_API='$CONTAINER_IMAGE_API'\",
            \"export CONTAINER_IMAGE_WEB='$CONTAINER_IMAGE_WEB'\",
            \"echo \\\"Environment check: AWS_ECR_REGISTRY=$REGISTRY\\\"\",
            \"echo \\\"Environment check: CONTAINER_IMAGE_API=$CONTAINER_IMAGE_API\\\"\",
            \"echo \\\"Environment check: CONTAINER_IMAGE_WEB=$CONTAINER_IMAGE_WEB\\\"\",
            \"./run-deployment.sh --config config.json\"
          ]" \
          --timeout-seconds 900 \
          --output text \
          --query "Command.CommandId")

        echo "SSM command ID: $CMD_ID"

        # Wait for command to complete (add a timeout to avoid waiting indefinitely)
        timeout 15m aws ssm wait command-executed \
          --command-id "$CMD_ID" \
          --instance-id "$INSTANCE_ID" || echo "Command timed out, continuing..."

        # Get command result
        RESULT=$(aws ssm get-command-invocation \
          --command-id "$CMD_ID" \
          --instance-id "$INSTANCE_ID" \
          --query "Status" \
          --output text || echo "Failed to get command status")

        echo "Command status: $RESULT"

        if [ "$RESULT" != "Success" ]; then
          echo "Deployment failed with status: $RESULT"
          
          # Get and display both standard output and error for debugging
          echo "Command output:"
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text || echo "Could not retrieve output content"
            
          echo "Command error:"
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardErrorContent" \
            --output text || echo "Could not retrieve error content"
          
          # Try to debug Docker issues specifically
          echo "Sending follow-up command to check Docker status..."
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"echo 'Registry value: $REGISTRY'\",
              \"echo 'API container: $CONTAINER_IMAGE_API'\",
              \"echo 'Web container: $CONTAINER_IMAGE_WEB'\",
              \"echo 'Environment variables:'\",
              \"env | grep AWS\",
              \"echo 'Docker version:'\",
              \"docker version || true\",
              \"echo 'Docker images:'\",
              \"docker images || true\",
              \"echo 'Docker containers:'\",
              \"docker ps -a || true\"
            ]" \
            --output text > /dev/null
          
          # Continue with error exit status
          exit 1
        fi

        echo "Deployment output:"
        aws ssm get-command-invocation \
          --command-id "$CMD_ID" \
          --instance-id "$INSTANCE_ID" \
          --query "StandardOutputContent" \
          --output text || echo "Could not retrieve output content"

        echo "Deployment completed successfully"